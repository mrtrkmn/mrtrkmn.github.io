<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go: concurrency notes | mrturkmen</title>
<meta name=keywords content="golang,go,google,coursera,programming,examples"><meta name=description content="Go Programming Language Notes."><meta name=author content="mrturkmen"><link rel=canonical href=https://mrturkmen.com/posts/go-concur/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.1c8109aae59ece680b41174ab99f289d7e8f786407fb56124777adbe23079081.css integrity="sha256-HIEJquWezmgLQRdKuZ8onX6PeGQH+1YSR3etviMHkIE=" rel="preload stylesheet" as=style><link rel=icon href=https://mrturkmen.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://mrturkmen.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://mrturkmen.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://mrturkmen.com/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://mrturkmen.com/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-165248542-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="go: concurrency notes "><meta property="og:description" content="Go Programming Language Notes."><meta property="og:type" content="article"><meta property="og:url" content="https://mrturkmen.com/posts/go-concur/"><meta property="og:image" content="https://mrturkmen.com/images/golangposts/header.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-13T10:00:03+00:00"><meta property="article:modified_time" content="2020-06-13T10:00:03+00:00"><meta property="og:site_name" content="Ahmet Turkmen"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mrturkmen.com/images/golangposts/header.png"><meta name=twitter:title content="go: concurrency notes "><meta name=twitter:description content="Go Programming Language Notes."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mrturkmen.com/posts/"},{"@type":"ListItem","position":2,"name":"go: concurrency notes ","item":"https://mrturkmen.com/posts/go-concur/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go: concurrency notes ","name":"go: concurrency notes ","description":"Go Programming Language Notes.","keywords":["golang","go","google","coursera","programming","examples"],"articleBody":"Concurrency in Go Concurrency in Go, makes Go programming language very unique and attractive compared to other languages, in this section I am going to share the notes which I took when I was watching coursera video series.\nIf you did not already check previous post on Go, it could be helpful to check it out first.\nGo Notes (OOP) Specialization serie is Programming with Google Go Keep in mind that the notes are taken from several resources mainly from the course, however post may include other resources as well, I have referenced them when required, if nothing is referenced then it means, notes are taken from the course.\nParalel Execution Two programs execute in paralel if they execute at exactly the same time At time t, an instruction is being performed for both P1 and P2. Why use parallel execution Tasks may complete more quickly Example: Two Piles of dishes to wash Two dishwashers can complete twice as fast as one Some tasks must be performed sequentially Example: Wash dish, dry dish Must wash before you can dry Some tasks are parallelizable and some are not Von Neumann Bottleneck Speedup without Parallelism Can we achieve speedup without Parallelism ? Design faster processors Get speedup without changing software Design processor with more memory Reduces the Von Heumann bottleneck Cache access time=1 clock cycle Main memory access time = ~100 clock cycles Increasing on-chip cache improves performance Moore‚Äôs Law Predicted that transistor density would double every two years Smaller transistors switch faster Not a physical law, just an observation Exponential increase in density would lead to exponential increase in speed Power Wall Power / Temperature Problem Transistors consume power when they switch Increasing transistor density leads to increased power consumption Smaller transistors use less power, but density scaling is much faster High power leads to high temperature Air cooling (fans) can only remove so much heat Dynamic Power P = a * CFV^2 a is percent of time switching C is capacitance (related to size) F is the clock frequency V is voltage swing (from low to high) Voltage is important 0 to 5V uses much more power then 0 to 1.3V Dennard Scaling Voltage should scale with transistor size Keeps power consumption and temperature, low Problem: Voltage can‚Äôt go too low Must stay above threshold voltage Noise problems occur Problem: Does not consider leakage power Dennard scaling must stop Multi-Core Systems P = a * CFV^2 Cannot increase frequency Can still add processor cores, without increasing frequency Trend is apparent today Parallel execution is needed to exploit multi-core systems Code made to execute on multiple cores Different programs on different cores Concurrent vs Parallel Concurrent Execution Concurrent execution is not necessarily the some as parallel execution Concurrent: start and end times overlap Parallel: execute at exactly the same time Parallel tasks must be executed on different hardware Concurrent tasks may be executed on the same hardware Only one task actually executed at a time Mapping from tasks to hardware is not directly controlled by programmer At least not in go Concurrent Programming Programmer determines which tasks can be executed in parallel Mapping tasks to hardware Operating system Go runtime scheduler Hiding Latency *(Crucial) Concurrency improves performance even without parallelism\nTasks must periodically wait for something\ni.e. wait for memory X = Y+Z read Y,Z from memory May wait 100+ clock cycles Other concurrent tasks can operate while one task is waiting\nConcurrent programming is useful even no paralelism\nHardware Mapping Programmer does not determine the hardware mapping Programmer makes parallelism possible Hardware mapping depends on many factors Where is the data ? What are the communication costs ? Concurrency Basics Processes An instance of a running program Things unique to a process Memory a. Virtual address space b. Code, stack, heap, shared libraries Registers a. Program counter Operating System Allows many processes to execute concurrently Processes are switched quickly 20ms User has the impression of parallelism Operating system must give processes fair access to resources Scheduling Processes Operating system schedules processes for execution Gives the illusion of parallel execution OS gives fair access to CPU, memory , etc. Context Switch Control flow changes from one process to another Process ‚Äúcontext‚Äù must be swapped Air cooling (fans) can only remove so much heat Threads and Goroutines Threads vs. Processes Threads share some context Many threads can exist in one process OS schedules threads rather than processes Goroutines Like a thread in Go Many Goroutines execute within a single OS thread We can call Goroutines as lightweight threads in Go.\nGo Runtime Scheduler Schedules goroutines inside an OS thread Like a little OS inside a single OS thread Logical processor is mapped to a thread Interleavings Order of execution within a task is known Order of execution between concurrent tasks is unknown Interleaving of instructions between tasks is unknown Possible Interleavings Many interleavings are possible Must consider all possibilities Ordering is non-deterministic Interleavings occurs on machine code level. Race Conditions It is happenning when multiple goroutines try to write/read from a source at the same time, could be prevented using mutex\nOutcome depends on non-deterministic ordering Races occur due to communication Communication Between Tasks Threads are largely independent but not completely independent Web server, one thread per client. Make threads for each client who are connecting to web server Image processing, 1 thread per pixel block Some level of communication can occur between threads, let‚Äôs say we want to blur the image accordingly, then the threads which are working on neighborhood pixels should communicate with each other. Goroutines Goroutines are new way of threading in lightweight approach.\nCreating a Goroutine One goroutine is created automatically to execute the main() Other goroutines are created using the go keyword package main func main () { a=1\tfoo()\ta=2 } func foo() { // does something ... } Main goroutine blocks on call to foo() package main func main () { a=1\tgo foo()\ta=2 } func foo() { // does something ... } New goroutine created for foo() Main goroutine does not block Exiting a Goroutine A goroutine exits when its code is complete When the main goroutine is complete, all other goroutines exit A goroutine may not complete its execution because main completes early Early Exit func main() { go fmt.Printf(\"New routine\") fmt.Printf(\"Main routine\") } Only ‚ÄúMain routine‚Äù is printed Main finished before the new goroutine started Delayed Exit func main() { go fmt.Printf(\"New routine\") time.Sleep(100 * time.Milisecond) fmt.Printf(\"Main routine\") } Add a delay in the main routine to give the new routine a chance to complete ‚ÄúNew RouteMainRoutine \" is now printed Timing with Goroutines Adding a delay to wait for a goroutine is bad !! Timing assumptions may be wrong Assumption: delay of 100 ms will ensure that goroutine has time to execute Maybe the OS schedules another thread Maybe the Go runtime schedules another goroutine Timing is nondeterministic Need formal synchronization constructs Synchronization Using global events whose execution is viewed by all threads, simultaneously Want print to occur after update of x Example\nTask 1 Task 2 x=1 x=x+1 GB if GB print x GLOBAL EVENT (GB) is viewed by all tasks at the same time Print must occur after update of x Synchronization is used to restrict bad interleavings Threads in Go Threads in Go are generally handled using wait groups\nSync WaitGroup Sync package contains functions to synchronize between goroutines sync.WaitGroup forces a goroutine to wait for other goroutines Contains an internal counter Increment counter for each goroutine to wait for Decrement counter when each goroutine Waiting goroutine cannot continue until counter is 0 Using WaitGroup Add() increments the counter Done() decrements the counter Wait() blocks until counter == 0 Example func foo(wg *sync.WaitGroup) { fmt.Printf(\"New routine\") wg.Done() } func main() { var wg sync.WaitGroup wg.Add(1) go foo(\u0026wg) wg.Wait() fmt.Printf(\"Main Routine\") } Goroutine Communication Goroutines usually work together to perform a bigger task Often need to send data to collaborate Example : Find the product of 4 integers Make 2 goroutines, each multiplines a pair Main goroutine multiplies the 2 results Need to send ints from main routine to the two sub-routines Need to send results from sub-routines back to main routine Channels Channels are used to make communication between goroutines Channels are typed Use make() to create a channel c:=make(chan int) Send and receive data using the \u003c- operator Send data on a channel C \u003c - 3 Receive data from a channel x:= \u003c- c Example func prod(v1 int, v2 int, c chan int) { c \u003c- v1*v2 } func main() { c:=make(chan int) go prod(1,2,c) go prod(3,4,c) a:= \u003c-c b:= \u003c-c fmt.Println(a*b) } Unbuffered Channel Unbuffered channels cannot hold data in transit Default is unbuffered Sending blocks until data is received Receiving blocks until data is sent Blocking and Synchronization Channel communication is synchronous Blocking is the same as waiting for communication Receiving and ignoring the result is same as a Wait() Buffered Channel Channel Capacity Channel can contain a limited number of objects Default size 0 (unbuffered) Capacity is the number of objects, it can hold in transit Optional argument to make() defines channel capacity c:=make(chan int, 3) Sending only blocks if buffer is full Receiving only blocks if buffer is empty Channel Blocking, Receive Channel with capacity 1 First receive blocks until send occurs Second receive blocks forever Channel Blocking, Send Second send blocks until receive is done Receive can block until first send is done Use of Buffering Sender and receiver do not need to operate at exactly the same speed Adding a channel to our goroutine Note that in this section notes are taken from: https://www.sohamkamani.com/blog/2017/08/24/golang-channels-explained\nA channel gives us a way to ‚Äúconnect \" the different concurrent parts of our program. Channels can be thought of as ‚Äúpipes‚Äù or ‚Äúarteries‚Äù that connect the different concurrent parts of our code Directionality out chan \u003c- int ` The chan\u003c- declaration tells us that you can only put stuff into the channel, but not receive anything from it. The int declaration tells us that the ‚Äústuff‚Äù you put into the channel can only be of the int datatype Although they look like seperate parts, chan\u003c-int can be thought of as one datatype, that describes a ‚Äúsend-only‚Äù channel of integers. Similarly, an example of a ‚Äúreceive-only‚Äù channel declaration would look like: out \u003c- chan int A channel can be declared without giving any directionatility, which means it can send or receive data.\nBi-directional channel can be created using following ‚Äúmake‚Äù statement\nout :=make(chan int) After this section, notes are taken from: https://go101.org/article/channel.html if you prefer to have deep dive into channels, you may visit there.\nConcurrent computations may share resources, generally memory resource. There are some circumstances may happen in a concurrent computing.\nIn the same period of one computation is writing data to a memory segment, another computation is reading data from the same memory segment. Then the integrity of the data read by the other computation might be not preserved.\nIn the same period of one computation is writing data to a memory segment, another computation is also writing data to the same memory segment. Then the integrity of the data stored at the memory segment might be not preserved.\nThese circumstances are called data races. One of the duties in concurrent programming is to control resource sharing among concurrent applications, so that data races will NOT happen. The ways to achieve this duty are called concurrency synchronization, or data synchronization. GO supports several data synchronization techniques. The following section will introduce one of them, channel.\nOther duties in concurrent programming include:\nDetermine how many computations are needed Determine when to start, block, unblock and end a computation. Determine how to distribute workload among concurrent computations. Most operations in Go are not synchronized. In other words, they are not concurrency-safe. These operations include value assignments, argument passing and container element manipulations. There are only a few operations which are synchronized, including the several to be introduced channel operations below.\nDO NOT COMMUNICATE BY SHARING MEMORY, SHARE MEMORY BY COMMUNICATING *(THROUGH CHANNELS)\nChannel Types and Values Like array, slice and map, each channel type has an element type. A channel can only transfer values of the element type of (the type of) the channel.\nChannel types can be bidirectional or single-directional. Assume T is an arbitrary type,\nchan T denotes a bidirectional channel type. Compilers allow both receiving values from and sending values to bidirectional channels. chan \u003c-T denotes a send-only channel type. Compilers do not allow receiving values from send-only channels. \u003c- chan T denotes a receive-only channel type. Compilers do not allow sending values to receive-only channels. T is called element types of these channel types.\nValues of bidirectional channel type chan T can be implicitly converted to both send-only type chan \u003c-T and receive-only type \u003c-chan T , but not vice versa (even if explicitly). Values of send only type chan\u003c-T cannot be converted to receive only type \u003c-chan T.\nEach channel has capacity. A channel value with a zero capacity is called unbuffered channel and a channel value with a non-zero capacity is called buffered channel.\nFor more detailed explanation on channels you can visit https://go101.org/article/channel.html\nTake care ! üëãüèª\nMaybe next time, topics could be revisited by examples üòâ\n","wordCount":"2211","inLanguage":"en","image":"https://mrturkmen.com/images/golangposts/header.png","datePublished":"2020-06-13T10:00:03Z","dateModified":"2020-06-13T10:00:03Z","author":{"@type":"Person","name":"mrturkmen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mrturkmen.com/posts/go-concur/"},"publisher":{"@type":"Organization","name":"mrturkmen","logo":{"@type":"ImageObject","url":"https://mrturkmen.com/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mrturkmen.com/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mrturkmen.com/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mrturkmen.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mrturkmen.com/>Home</a>&nbsp;¬ª&nbsp;<a href=https://mrturkmen.com/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">go: concurrency notes</h1><div class=post-description>Go Programming Language Notes.</div><div class=post-meta><span title='2020-06-13 10:00:03 +0000 UTC'>June 13, 2020</span>&nbsp;¬∑&nbsp;11 min&nbsp;¬∑&nbsp;mrturkmen&nbsp;|&nbsp;<a href=https://github.com/mrtrkmn/mrtrkmn.github.io/tree/master/content/posts/go-concur.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#concurrency-in-go aria-label="Concurrency in Go">Concurrency in Go</a><ul><li><a href=#paralel-execution aria-label="Paralel Execution">Paralel Execution</a><ul><li><a href=#why-use-parallel-execution aria-label="Why use parallel execution">Why use parallel execution</a></li></ul></li><li><a href=#von-neumann-bottleneck aria-label="Von Neumann Bottleneck">Von Neumann Bottleneck</a><ul><li><a href=#speedup-without-parallelism aria-label="Speedup without Parallelism">Speedup without Parallelism</a></li></ul></li><li><a href=#moores-law aria-label="Moore&rsquo;s Law">Moore&rsquo;s Law</a></li><li><a href=#power-wall aria-label="Power Wall">Power Wall</a><ul><li><a href=#power--temperature-problem aria-label="Power / Temperature Problem">Power / Temperature Problem</a></li><li><a href=#dynamic-power aria-label="Dynamic Power">Dynamic Power</a></li><li><a href=#dennard-scaling aria-label="Dennard Scaling">Dennard Scaling</a></li><li><a href=#multi-core-systems aria-label="Multi-Core Systems">Multi-Core Systems</a></li></ul></li><li><a href=#concurrent-vs-parallel aria-label="Concurrent vs Parallel">Concurrent vs Parallel</a><ul><li><a href=#concurrent-execution aria-label="Concurrent Execution">Concurrent Execution</a></li><li><a href=#concurrent-programming aria-label="Concurrent Programming">Concurrent Programming</a></li><li><a href=#hiding-latency-crucial aria-label="Hiding Latency *(Crucial)">Hiding Latency *(Crucial)</a></li><li><a href=#hardware-mapping aria-label="Hardware Mapping">Hardware Mapping</a></li></ul></li><li><a href=#concurrency-basics aria-label="Concurrency Basics">Concurrency Basics</a><ul><li><a href=#processes aria-label=Processes>Processes</a></li><li><a href=#operating-system aria-label="Operating System">Operating System</a></li><li><a href=#scheduling-processes aria-label="Scheduling Processes">Scheduling Processes</a></li><li><a href=#context-switch aria-label="Context Switch">Context Switch</a></li></ul></li><li><a href=#threads-and-goroutines aria-label="Threads and Goroutines">Threads and Goroutines</a><ul><li><a href=#threads-vs-processes aria-label="Threads vs. Processes">Threads vs. Processes</a></li></ul></li><li><a href=#goroutines aria-label=Goroutines>Goroutines</a><ul><li><a href=#go-runtime-scheduler aria-label="Go Runtime Scheduler">Go Runtime Scheduler</a></li><li><a href=#interleavings aria-label=Interleavings>Interleavings</a></li><li><a href=#possible-interleavings aria-label="Possible Interleavings">Possible Interleavings</a></li><li><a href=#race-conditions aria-label="Race Conditions">Race Conditions</a></li></ul></li><li><a href=#communication-between-tasks aria-label="Communication Between Tasks">Communication Between Tasks</a></li><li><a href=#goroutines-1 aria-label=Goroutines>Goroutines</a><ul><li><a href=#creating-a-goroutine aria-label="Creating a Goroutine">Creating a Goroutine</a></li><li><a href=#exiting-a-goroutine aria-label="Exiting a Goroutine">Exiting a Goroutine</a><ul><li><a href=#early-exit aria-label="Early Exit">Early Exit</a></li><li><a href=#delayed-exit aria-label="Delayed Exit">Delayed Exit</a></li></ul></li></ul></li><li><a href=#timing-with-goroutines aria-label="Timing with Goroutines">Timing with Goroutines</a><ul><li><a href=#synchronization aria-label=Synchronization>Synchronization</a></li></ul></li><li><a href=#threads-in-go aria-label="Threads in Go">Threads in Go</a><ul><li><a href=#sync-waitgroup aria-label="Sync WaitGroup">Sync WaitGroup</a></li><li><a href=#using-waitgroup aria-label="Using WaitGroup">Using WaitGroup</a><ul><li><a href=#example aria-label=Example>Example</a></li></ul></li></ul></li><li><a href=#goroutine-communication aria-label="Goroutine Communication">Goroutine Communication</a></li><li><a href=#channels aria-label=Channels>Channels</a><ul><li><a href=#example-1 aria-label=Example>Example</a></li></ul></li><li><a href=#unbuffered-channel aria-label="Unbuffered Channel">Unbuffered Channel</a></li><li><a href=#blocking-and-synchronization aria-label="Blocking and Synchronization">Blocking and Synchronization</a></li><li><a href=#buffered-channel aria-label="Buffered Channel">Buffered Channel</a><ul><li><a href=#channel-capacity aria-label="Channel Capacity">Channel Capacity</a></li><li><a href=#channel-blocking-receive aria-label="Channel Blocking, Receive">Channel Blocking, Receive</a></li><li><a href=#channel-blocking-send aria-label="Channel Blocking, Send">Channel Blocking, Send</a></li><li><a href=#use-of-buffering aria-label="Use of Buffering">Use of Buffering</a></li></ul></li><li><a href=#adding-a-channel-to-our-goroutine aria-label="Adding a channel to our goroutine">Adding a channel to our goroutine</a><ul><li><a href=#directionality aria-label=Directionality>Directionality</a></li></ul></li><li><a href=#channel-types-and-values aria-label="Channel Types and Values">Channel Types and Values</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=concurrency-in-go>Concurrency in Go<a hidden class=anchor aria-hidden=true href=#concurrency-in-go>#</a></h1><p>Concurrency in Go, makes Go programming language very unique and attractive compared to other languages, in this section I am going to share the notes which I took when I was watching coursera video series.</p><p>If you did not already check previous post on Go, it could be helpful to check it out first.</p><ul><li><a href=/go-notes/>Go Notes (OOP)</a></li></ul><p>Specialization serie is <a href=https://www.coursera.org/specializations/google-golang>Programming with Google Go</a></p><p>Keep in mind that the notes are taken from several resources mainly from the course, however post may include other resources as well, I have referenced them when required, if nothing is referenced then it means, notes are taken from the course.</p><h2 id=paralel-execution>Paralel Execution<a hidden class=anchor aria-hidden=true href=#paralel-execution>#</a></h2><ul><li>Two programs execute in paralel if they execute at exactly the same time</li><li>At time <code>t</code>, an instruction is being performed for both <code>P1</code> and <code>P2</code>.</li></ul><h3 id=why-use-parallel-execution>Why use parallel execution<a hidden class=anchor aria-hidden=true href=#why-use-parallel-execution>#</a></h3><ul><li>Tasks may complete more quickly</li><li>Example: Two Piles of dishes to wash<ul><li>Two dishwashers can complete twice as fast as one</li></ul></li><li>Some tasks must be performed sequentially<ul><li>Example: Wash dish, dry dish<ul><li>Must wash before you can dry</li></ul></li></ul></li><li><strong>Some tasks are parallelizable and some are not</strong></li></ul><h2 id=von-neumann-bottleneck>Von Neumann Bottleneck<a hidden class=anchor aria-hidden=true href=#von-neumann-bottleneck>#</a></h2><h3 id=speedup-without-parallelism>Speedup without Parallelism<a hidden class=anchor aria-hidden=true href=#speedup-without-parallelism>#</a></h3><ul><li>Can we achieve speedup without Parallelism ?</li><li>Design faster processors<ul><li>Get speedup without changing software</li></ul></li><li>Design processor with more memory<ul><li>Reduces the Von Heumann bottleneck</li><li>Cache access time=1 clock cycle</li><li>Main memory access time = ~100 clock cycles</li><li>Increasing on-chip cache improves performance</li></ul></li></ul><h2 id=moores-law>Moore&rsquo;s Law<a hidden class=anchor aria-hidden=true href=#moores-law>#</a></h2><ul><li>Predicted that transistor density would double every two years</li><li>Smaller transistors switch faster</li><li>Not a physical law, just an observation</li><li>Exponential increase in density would lead to exponential increase in speed</li></ul><h2 id=power-wall>Power Wall<a hidden class=anchor aria-hidden=true href=#power-wall>#</a></h2><h3 id=power--temperature-problem>Power / Temperature Problem<a hidden class=anchor aria-hidden=true href=#power--temperature-problem>#</a></h3><ul><li>Transistors consume power when they switch</li><li>Increasing transistor density leads to increased power consumption<ul><li>Smaller transistors use less power, but density scaling is much faster</li></ul></li><li>High power leads to high temperature</li><li>Air cooling (fans) can only remove so much heat</li></ul><h3 id=dynamic-power>Dynamic Power<a hidden class=anchor aria-hidden=true href=#dynamic-power>#</a></h3><ul><li><code>P = a * CFV^2</code></li><li><code>a</code> is percent of time switching</li><li><code>C</code> is capacitance (related to size)</li><li><code>F</code> is the clock frequency</li><li>V is voltage swing (from low to high)</li><li>Voltage is important</li><li>0 to 5V uses much more power then 0 to 1.3V</li></ul><h3 id=dennard-scaling>Dennard Scaling<a hidden class=anchor aria-hidden=true href=#dennard-scaling>#</a></h3><ul><li>Voltage should scale with transistor size</li><li>Keeps power consumption and temperature, low</li><li>Problem: Voltage can&rsquo;t go too low<ul><li>Must stay above threshold voltage</li><li>Noise problems occur</li></ul></li><li>Problem: Does not consider leakage power</li><li>Dennard scaling must stop</li></ul><h3 id=multi-core-systems>Multi-Core Systems<a hidden class=anchor aria-hidden=true href=#multi-core-systems>#</a></h3><ul><li><code>P = a * CFV^2</code></li><li>Cannot increase frequency</li><li>Can still add processor cores, without increasing frequency<ul><li>Trend is apparent today</li></ul></li><li>Parallel execution is needed to exploit multi-core systems</li><li>Code made to execute on multiple cores</li><li>Different programs on different cores</li></ul><h2 id=concurrent-vs-parallel>Concurrent vs Parallel<a hidden class=anchor aria-hidden=true href=#concurrent-vs-parallel>#</a></h2><h3 id=concurrent-execution>Concurrent Execution<a hidden class=anchor aria-hidden=true href=#concurrent-execution>#</a></h3><ul><li>Concurrent execution is not necessarily the some as parallel execution</li><li><strong>Concurrent: start and end times overlap</strong></li><li><strong>Parallel: execute at exactly the same time</strong></li></ul><p><img loading=lazy src=../../images/golangposts/concurrency_ex.png alt="Concurrency Example"></p><ul><li>Parallel tasks must be executed on different hardware</li><li>Concurrent tasks may be executed on the same hardware<ul><li>Only one task actually executed at a time</li></ul></li><li>Mapping from tasks to hardware is not directly controlled by programmer<ul><li>At least not in go</li></ul></li></ul><h3 id=concurrent-programming>Concurrent Programming<a hidden class=anchor aria-hidden=true href=#concurrent-programming>#</a></h3><ul><li>Programmer determines which tasks can be executed in parallel</li><li>Mapping tasks to hardware<ul><li>Operating system</li><li>Go runtime scheduler</li></ul></li></ul><h3 id=hiding-latency-crucial>Hiding Latency *(Crucial)<a hidden class=anchor aria-hidden=true href=#hiding-latency-crucial>#</a></h3><ul><li><p>Concurrency improves performance even without parallelism</p></li><li><p>Tasks must periodically wait for something</p><ul><li>i.e. wait for memory</li><li>X = Y+Z read Y,Z from memory</li><li>May wait 100+ clock cycles</li></ul></li><li><p>Other concurrent tasks can operate while one task is waiting</p></li><li><p>Concurrent programming is useful even no paralelism</p></li></ul><h3 id=hardware-mapping>Hardware Mapping<a hidden class=anchor aria-hidden=true href=#hardware-mapping>#</a></h3><p><img loading=lazy src=../../images/golangposts/parallel_concurrent.png alt="Parallel &amp;amp; Concurrency"></p><ul><li>Programmer does not determine the hardware mapping</li><li>Programmer makes parallelism possible</li><li>Hardware mapping depends on many factors<ul><li>Where is the data ?</li><li>What are the communication costs ?</li></ul></li></ul><p><img loading=lazy src=../../images/golangposts/shared_mem.png alt="Shared Mem"></p><h2 id=concurrency-basics>Concurrency Basics<a hidden class=anchor aria-hidden=true href=#concurrency-basics>#</a></h2><h3 id=processes>Processes<a hidden class=anchor aria-hidden=true href=#processes>#</a></h3><ul><li>An instance of a running program</li><li>Things unique to a process</li></ul><ol><li>Memory</li></ol><ul><li>a. Virtual address space</li><li>b. Code, stack, heap, shared libraries</li></ul><ol start=2><li>Registers</li></ol><ul><li>a. Program counter</li></ul><h3 id=operating-system>Operating System<a hidden class=anchor aria-hidden=true href=#operating-system>#</a></h3><ul><li>Allows many processes to execute concurrently</li><li>Processes are switched quickly<ul><li>20ms</li></ul></li><li>User has the impression of parallelism</li><li>Operating system must give processes fair access to resources</li></ul><h3 id=scheduling-processes>Scheduling Processes<a hidden class=anchor aria-hidden=true href=#scheduling-processes>#</a></h3><ul><li>Operating system schedules processes for execution</li><li>Gives the illusion of parallel execution</li></ul><p><img loading=lazy src=../../images/golangposts/scheduler.png alt="Scheduler processes"></p><ul><li>OS gives fair access to CPU, memory , etc.</li></ul><h3 id=context-switch>Context Switch<a hidden class=anchor aria-hidden=true href=#context-switch>#</a></h3><ul><li>Control flow changes from one process to another</li></ul><p><img loading=lazy src=../../images/golangposts/control_flow.png alt="Scheduler processes"></p><ul><li>Process &ldquo;context&rdquo; must be swapped</li><li>Air cooling (fans) can only remove so much heat</li></ul><h2 id=threads-and-goroutines>Threads and Goroutines<a hidden class=anchor aria-hidden=true href=#threads-and-goroutines>#</a></h2><h3 id=threads-vs-processes>Threads vs. Processes<a hidden class=anchor aria-hidden=true href=#threads-vs-processes>#</a></h3><ul><li>Threads share some context</li><li>Many threads can exist in one process</li></ul><p><img loading=lazy src=../../images/golangposts/threads_processes.png alt="Threads vs Processes"></p><ul><li>OS schedules threads rather than processes</li></ul><h2 id=goroutines>Goroutines<a hidden class=anchor aria-hidden=true href=#goroutines>#</a></h2><ul><li>Like a thread in Go</li><li>Many Goroutines execute within a single OS thread</li></ul><p><img loading=lazy src=../../images/golangposts/process.png alt=Process></p><p>We can call Goroutines as lightweight threads in Go.</p><h3 id=go-runtime-scheduler>Go Runtime Scheduler<a hidden class=anchor aria-hidden=true href=#go-runtime-scheduler>#</a></h3><ul><li>Schedules goroutines inside an OS thread</li><li>Like a little OS inside a single OS thread</li></ul><p><img loading=lazy src=../../images/golangposts/goroutines.png alt=Process></p><ul><li>Logical processor is mapped to a thread</li></ul><h3 id=interleavings>Interleavings<a hidden class=anchor aria-hidden=true href=#interleavings>#</a></h3><ul><li>Order of execution within a task is known</li></ul><p><img loading=lazy src=../../images/golangposts/interleaving.png alt=Interleaving></p><ul><li>Order of execution between concurrent tasks is unknown</li><li>Interleaving of instructions between tasks is unknown</li></ul><h3 id=possible-interleavings>Possible Interleavings<a hidden class=anchor aria-hidden=true href=#possible-interleavings>#</a></h3><ul><li>Many interleavings are possible</li><li>Must consider all possibilities</li></ul><p><img loading=lazy src=../../images/golangposts/possible_interleaving.png alt="Possible Interleaving"></p><ul><li>Ordering is non-deterministic</li><li>Interleavings occurs on machine code level.</li></ul><h3 id=race-conditions>Race Conditions<a hidden class=anchor aria-hidden=true href=#race-conditions>#</a></h3><p>It is happenning when multiple goroutines try to write/read from a source at the same time, could be prevented using <a href=https://golang.org/pkg/sync/#Mutex>mutex</a></p><ul><li>Outcome depends on non-deterministic ordering</li></ul><p><img loading=lazy src=../../images/golangposts/race_condition.png alt="Possible Interleaving"></p><ul><li>Races occur due to communication</li></ul><h2 id=communication-between-tasks>Communication Between Tasks<a hidden class=anchor aria-hidden=true href=#communication-between-tasks>#</a></h2><ul><li>Threads are largely independent but not completely independent</li><li>Web server, one thread per client.</li></ul><p><img loading=lazy src=../../images/golangposts/web_server_p_client.png alt="Web Server Per Client"></p><ul><li>Make threads for each client who are connecting to web server</li><li>Image processing, 1 thread per pixel block</li></ul><p><img loading=lazy src=../../images/golangposts/img_processing.png alt="Image processing 1 thread per pixel"></p><ul><li>Some level of communication can occur between threads, let&rsquo;s say we want to blur the image accordingly, then the threads which are working on neighborhood pixels should communicate with each other.</li></ul><h2 id=goroutines-1>Goroutines<a hidden class=anchor aria-hidden=true href=#goroutines-1>#</a></h2><p>Goroutines are new way of threading in lightweight approach.</p><h3 id=creating-a-goroutine>Creating a Goroutine<a hidden class=anchor aria-hidden=true href=#creating-a-goroutine>#</a></h3><ul><li>One goroutine is created automatically to execute the main()</li><li>Other goroutines are created using the go keyword</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span> () {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>a</span>=<span style=color:#ae81ff>1</span>		                 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>foo</span>()	                 
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>a</span>=<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// does something ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span><span style=display:flex><span> 		                
</span></span></code></pre></div><ul><li>Main goroutine blocks on call to <code>foo()</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span>=<span style=color:#ae81ff>1</span>		                 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>foo</span>()	                 
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span>=<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>() {
</span></span><span style=display:flex><span>     <span style=color:#75715e>// does something ... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span><span style=display:flex><span> 		  
</span></span></code></pre></div><ul><li>New goroutine created for <code>foo()</code></li><li>Main goroutine does not block</li></ul><h3 id=exiting-a-goroutine>Exiting a Goroutine<a hidden class=anchor aria-hidden=true href=#exiting-a-goroutine>#</a></h3><ul><li>A goroutine exits when its code is complete</li><li>When the main goroutine is complete, all other goroutines exit</li><li>A goroutine may not complete its execution because main completes early</li></ul><h4 id=early-exit>Early Exit<a hidden class=anchor aria-hidden=true href=#early-exit>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;New routine&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Main routine&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Only &ldquo;Main routine&rdquo; is printed</li><li>Main finished before the new goroutine started</li></ul><h4 id=delayed-exit>Delayed Exit<a hidden class=anchor aria-hidden=true href=#delayed-exit>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;New routine&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>100</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Milisecond</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Main routine&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Add a delay in the main routine to give the new routine a chance to complete</li><li>&ldquo;New RouteMainRoutine " is now printed</li></ul><h2 id=timing-with-goroutines>Timing with Goroutines<a hidden class=anchor aria-hidden=true href=#timing-with-goroutines>#</a></h2><ul><li>Adding a delay to wait for a goroutine is bad !!</li><li>Timing assumptions may be wrong<ul><li>Assumption: delay of 100 ms will ensure that goroutine has time to execute</li><li>Maybe the OS schedules another thread</li><li>Maybe the Go runtime schedules another goroutine</li></ul></li><li><strong>Timing is nondeterministic</strong></li><li>Need formal synchronization constructs</li></ul><h3 id=synchronization>Synchronization<a hidden class=anchor aria-hidden=true href=#synchronization>#</a></h3><ul><li>Using global events whose execution is viewed by all threads, simultaneously</li><li>Want print to occur after update of x</li></ul><p><strong>Example</strong></p><table><thead><tr><th>Task 1</th><th>Task 2</th></tr></thead><tbody><tr><td>x=1</td><td></td></tr><tr><td>x=x+1</td><td></td></tr><tr><td>GB</td><td>if GB print x</td></tr></tbody></table><ul><li>GLOBAL EVENT (GB) is viewed by all tasks at the same time</li><li>Print must occur after update of x</li><li>Synchronization is used to restrict bad interleavings</li></ul><h2 id=threads-in-go>Threads in Go<a hidden class=anchor aria-hidden=true href=#threads-in-go>#</a></h2><p>Threads in Go are generally handled using <a href=https://golang.org/pkg/sync/#WaitGroup>wait groups</a></p><h3 id=sync-waitgroup>Sync WaitGroup<a hidden class=anchor aria-hidden=true href=#sync-waitgroup>#</a></h3><ul><li><a href=https://golang.org/pkg/sync/#pkg-overview>Sync package</a> contains functions to synchronize between goroutines</li><li><a href=https://golang.org/pkg/sync/#WaitGroup>sync.WaitGroup</a> forces a goroutine to wait for other goroutines</li><li>Contains an internal counter<ul><li>Increment counter for each goroutine to wait for</li><li>Decrement counter when each goroutine</li><li>Waiting goroutine cannot continue until counter is 0</li></ul></li></ul><h3 id=using-waitgroup>Using WaitGroup<a hidden class=anchor aria-hidden=true href=#using-waitgroup>#</a></h3><p><img loading=lazy src=../../images/golangposts/waitgroups.png alt=WaitGroups></p><ul><li><code>Add()</code> increments the counter</li><li><code>Done()</code> decrements the counter</li><li><code>Wait()</code> blocks until counter == 0</li></ul><h4 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>foo</span>(<span style=color:#a6e22e>wg</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;New routine&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span> 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>foo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wg</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Main Routine&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=goroutine-communication>Goroutine Communication<a hidden class=anchor aria-hidden=true href=#goroutine-communication>#</a></h2><ul><li>Goroutines usually work together to perform a bigger task</li><li>Often need to send data to collaborate</li><li>Example : Find the product of 4 integers<ul><li>Make 2 goroutines, each multiplines a pair</li><li>Main goroutine multiplies the 2 results</li></ul></li><li>Need to send ints from main routine to the two sub-routines</li><li>Need to send results from sub-routines back to main routine</li></ul><h2 id=channels>Channels<a hidden class=anchor aria-hidden=true href=#channels>#</a></h2><ul><li>Channels are used to make communication between goroutines</li><li>Channels are typed</li><li>Use make() to create a channel<ul><li><code>c:=make(chan int)</code></li></ul></li><li>Send and receive data using the &lt;- operator</li><li>Send data on a channel<ul><li><code>C &lt; - 3</code></li></ul></li><li>Receive data from a channel</li><li><code>x:= &lt;- c</code></li></ul><h3 id=example-1>Example<a hidden class=anchor aria-hidden=true href=#example-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>prod</span>(<span style=color:#a6e22e>v1</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>v2</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>c</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>v1</span><span style=color:#f92672>*</span><span style=color:#a6e22e>v2</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span><span style=color:#f92672>:=</span>make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>prod</span>(<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>2</span>,<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>go</span> <span style=color:#a6e22e>prod</span>(<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>a</span><span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span><span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span> 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>a</span><span style=color:#f92672>*</span><span style=color:#a6e22e>b</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=unbuffered-channel>Unbuffered Channel<a hidden class=anchor aria-hidden=true href=#unbuffered-channel>#</a></h2><ul><li>Unbuffered channels cannot hold data in transit<ul><li>Default is unbuffered</li></ul></li><li>Sending blocks until data is received</li><li>Receiving blocks until data is sent</li></ul><p><img loading=lazy src=../../images/golangposts/block_channel.png alt="Block Channel"></p><h2 id=blocking-and-synchronization>Blocking and Synchronization<a hidden class=anchor aria-hidden=true href=#blocking-and-synchronization>#</a></h2><ul><li>Channel communication is synchronous</li><li>Blocking is the same as waiting for communication</li><li>Receiving and ignoring the result is same as a Wait()</li></ul><h2 id=buffered-channel>Buffered Channel<a hidden class=anchor aria-hidden=true href=#buffered-channel>#</a></h2><h3 id=channel-capacity>Channel Capacity<a hidden class=anchor aria-hidden=true href=#channel-capacity>#</a></h3><ul><li>Channel can contain a limited number of objects</li><li>Default size 0 (unbuffered)</li><li>Capacity is the number of objects, it can hold in transit</li><li>Optional argument to make() defines channel capacity<ul><li><code>c:=make(chan int, 3)</code></li></ul></li><li>Sending only blocks <strong>if buffer is full</strong></li><li>Receiving only blocks <strong>if buffer is empty</strong></li></ul><h3 id=channel-blocking-receive>Channel Blocking, Receive<a hidden class=anchor aria-hidden=true href=#channel-blocking-receive>#</a></h3><ul><li>Channel with capacity 1</li></ul><p><img loading=lazy src=../../images/golangposts/channel_cap_1.png alt="Chan cap"></p><ul><li>First receive blocks until send occurs</li><li>Second receive blocks forever</li></ul><h3 id=channel-blocking-send>Channel Blocking, Send<a hidden class=anchor aria-hidden=true href=#channel-blocking-send>#</a></h3><p><img loading=lazy src=../../images/golangposts/chan_block_send.png alt="Chan Block Send"></p><ul><li>Second send blocks until receive is done</li><li>Receive can block until first send is done</li></ul><h3 id=use-of-buffering>Use of Buffering<a hidden class=anchor aria-hidden=true href=#use-of-buffering>#</a></h3><ul><li>Sender and receiver do not need to operate at exactly the same speed</li></ul><p><img loading=lazy src=../../images/golangposts/use_buffering.png alt="Buffering in channel"></p><h2 id=adding-a-channel-to-our-goroutine>Adding a channel to our goroutine<a hidden class=anchor aria-hidden=true href=#adding-a-channel-to-our-goroutine>#</a></h2><p><strong>Note that in this section notes are taken from: <a href=https://www.sohamkamani.com/blog/2017/08/24/golang-channels-explained>https://www.sohamkamani.com/blog/2017/08/24/golang-channels-explained</a></strong></p><ul><li>A channel gives us a way to &ldquo;connect " the different concurrent parts of our program.</li><li>Channels can be thought of as &ldquo;pipes&rdquo; or &ldquo;arteries&rdquo; that connect the different concurrent parts of our code</li></ul><h3 id=directionality>Directionality<a hidden class=anchor aria-hidden=true href=#directionality>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>out</span> <span style=color:#66d9ef>chan</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>int</span>  <span style=color:#960050;background-color:#1e0010>`</span>
</span></span></code></pre></div><ul><li>The chan&lt;- declaration tells us that you can only put stuff into the channel, but not receive anything from it.</li><li>The int declaration tells us that the &ldquo;stuff&rdquo; you put into the channel can only be of the int datatype</li><li>Although they look like seperate parts, chan&lt;-int can be thought of as one datatype, that describes a &ldquo;send-only&rdquo; channel of integers.</li><li>Similarly, an example of a &ldquo;receive-only&rdquo; channel declaration would look like:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>out</span> <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><ul><li><p>A channel can be declared without giving any directionatility, which means it can send or receive data.</p></li><li><p>Bi-directional channel can be created using following &ldquo;make&rdquo; statement</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>out</span> <span style=color:#f92672>:=</span>make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>int</span>)
</span></span></code></pre></div><p><strong>After this section, notes are taken from: <a href=https://go101.org/article/channel.html>https://go101.org/article/channel.html</a></strong> if you prefer to have deep dive into channels, you may visit there.</p><p><img loading=lazy src=../../images/golangposts/concurrent_vs_parallel.png alt="Buffering in channel"></p><ul><li><p>Concurrent computations may share resources, generally memory resource. There are some circumstances may happen in a concurrent computing.</p></li><li><p>In the same period of one computation is writing data to a memory segment, another computation is reading data from the same memory segment. Then the integrity of the data read by the other computation might be not preserved.</p></li><li><p>In the same period of one computation is writing data to a memory segment, another computation is also writing data to the same memory segment. Then the integrity of the data stored at the memory segment might be not preserved.</p></li></ul><p>These circumstances are called data races. One of the duties in concurrent programming is to control resource sharing among concurrent applications, so that data races will NOT happen. The ways to achieve this duty are called concurrency synchronization, or data synchronization. GO supports several data synchronization techniques. The following section will introduce one of them, channel.</p><p>Other duties in concurrent programming include:</p><ul><li>Determine how many computations are needed</li><li>Determine when to start, block, unblock and end a computation.</li><li>Determine how to distribute workload among concurrent computations.</li></ul><p>Most operations in Go are not synchronized. In other words, they are not concurrency-safe. These operations include value assignments, argument passing and container element manipulations. There are only a few operations which are synchronized, including the several to be introduced channel operations below.</p><p><strong>DO NOT COMMUNICATE BY SHARING MEMORY, SHARE MEMORY BY COMMUNICATING *(THROUGH CHANNELS)</strong></p><h2 id=channel-types-and-values>Channel Types and Values<a hidden class=anchor aria-hidden=true href=#channel-types-and-values>#</a></h2><p>Like array, slice and map, each channel type has an element type. A channel can only transfer values of the element type of (the type of) the channel.</p><p>Channel types can be bidirectional or single-directional. Assume T is an arbitrary type,</p><ul><li><code>chan T</code> denotes a bidirectional channel type. Compilers allow both receiving values from and sending values to bidirectional channels.</li><li><code>chan &lt;-T</code> denotes a send-only channel type. Compilers do not allow receiving values from send-only channels.</li><li><code>&lt;- chan T</code> denotes a receive-only channel type. Compilers do not allow sending values to receive-only channels.</li></ul><p><code>T</code> is called element types of these channel types.</p><p>Values of bidirectional channel type chan T can be implicitly converted to both send-only type <code>chan &lt;-T</code> and receive-only type <code>&lt;-chan T</code> , but not vice versa (even if explicitly). Values of send only type chan&lt;-T cannot be converted to receive only type <code>&lt;-chan T</code>.</p><p><strong>Each channel has capacity. A channel value with a zero capacity is called unbuffered channel and a channel value with a non-zero capacity is called buffered channel.</strong></p><p>For more detailed explanation on channels you can visit <a href=https://go101.org/article/channel.html>https://go101.org/article/channel.html</a></p><p>Take care ! üëãüèª</p><p>Maybe next time, topics could be revisited by examples üòâ</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://mrturkmen.com/tags/golang/>golang</a></li><li><a href=https://mrturkmen.com/tags/go/>go</a></li><li><a href=https://mrturkmen.com/tags/google/>google</a></li><li><a href=https://mrturkmen.com/tags/coursera/>coursera</a></li><li><a href=https://mrturkmen.com/tags/programming/>programming</a></li><li><a href=https://mrturkmen.com/tags/examples/>examples</a></li></ul><nav class=paginav><a class=prev href=https://mrturkmen.com/posts/vpn-kuralim/><span class=title>¬´ Prev</span><br><span>wireguard: kendimize √∂zel vpn kurulumu </span></a><a class=next href=https://mrturkmen.com/posts/go-notes/><span class=title>Next ¬ª</span><br><span>go: object oriented programming notes</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on x" href="https://x.com/intent/tweet/?text=go%3a%20concurrency%20notes%20&amp;url=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f&amp;hashtags=golang%2cgo%2cgoogle%2ccoursera%2cprogramming%2cexamples"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f&amp;title=go%3a%20concurrency%20notes%20&amp;summary=go%3a%20concurrency%20notes%20&amp;source=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f&title=go%3a%20concurrency%20notes%20"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on whatsapp" href="https://api.whatsapp.com/send?text=go%3a%20concurrency%20notes%20%20-%20https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on telegram" href="https://telegram.me/share/url?text=go%3a%20concurrency%20notes%20&amp;url=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share go: concurrency notes  on ycombinator" href="https://news.ycombinator.com/submitlink?t=go%3a%20concurrency%20notes%20&u=https%3a%2f%2fmrturkmen.com%2fposts%2fgo-concur%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mrturkmen.com/>mrturkmen</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script defer src=https://static.cloudflareinsights.com/beacon.min.js data-cf-beacon='{"token": "866620f03a6a4a5d9b8e6cd46edf203e"}'></script></body></html>