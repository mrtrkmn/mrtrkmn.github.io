<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>elasticsearch/performans | mrturkmen</title><meta name=keywords content="elasticsearch,cluster,performans,performance"><meta name=description content="Elasticsearch ortamı performans artırımı"><meta name=author content="mrturkmen"><link rel=canonical href=https://mrtrkmn.github.io/posts/elasticsearch-performans-art%C4%B1r%C4%B1m%C4%B1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.04512c372388e08b5118f5b117b2d3efef4ddae52017e16085c8d8d4e361c43d.css integrity="sha256-BFEsNyOI4ItRGPWxF7LT7+9N2uUgF+FghcjY1ONhxD0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://mrtrkmn.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://mrtrkmn.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://mrtrkmn.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://mrtrkmn.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://mrtrkmn.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.81.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-165248542-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="elasticsearch/performans "><meta property="og:description" content="Elasticsearch ortamı performans artırımı"><meta property="og:type" content="article"><meta property="og:url" content="https://mrtrkmn.github.io/posts/elasticsearch-performans-art%C4%B1r%C4%B1m%C4%B1/"><meta property="og:image" content="https://mrtrkmn.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-02-17T09:04:03+00:00"><meta property="article:modified_time" content="2019-02-17T09:04:03+00:00"><meta property="og:site_name" content="Ahmet Turkmen"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mrtrkmn.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="elasticsearch/performans "><meta name=twitter:description content="Elasticsearch ortamı performans artırımı"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mrtrkmn.github.io/posts/"},{"@type":"ListItem","position":2,"name":"elasticsearch/performans ","item":"https://mrtrkmn.github.io/posts/elasticsearch-performans-art%C4%B1r%C4%B1m%C4%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"elasticsearch/performans ","name":"elasticsearch\/performans ","description":"Elasticsearch ortamı performans artırımı","keywords":["elasticsearch","cluster","performans","performance"],"articleBody":"Giriş Elasticsearch üzerinde büyük boyuttaki verileri hızlı bir şekilde işlemek çaba gerektiren işlerden biridir. Bu yazıda bir çalışma esnasında yapılan elasticsearch performans iyileştirmelerini ve nasıl yapıldığını anlatmaya çalışacağım.\nBu iyileştirme işlemlerinin nasıl yapıldığına geçmeden once elasticsearch mimarisinde bulunan bazı bileşenlerden bahsetmekte yarar var.\n Cluster : Elasticsearch bir veya birden fazla bilgisayarda entegre şekilde çalışabilir ve bu elasticsearch ün çalıştığı makinelere NODE denir. Cluster (Küme) ise bu node’ların oluşturduğu gruba verilen yapıya denir. Index : Elasticsearch üzerinde veriler indexlerde tutulur, index basit olarak dökümanların toplandığı ve tutulduğu yapıdır. Shard: Elasticsearch ü birden fazla makine üzerinde (sanal veya fiziksel makine) tutabildiğimizden dolayı, indekslerde tutulan veriler bu cluster adı verdiğimiz ortamlarda dağıtık (distributed) şekilde tutulur. Bu işlemin yönetim kısmını elasticsearch otomatik olarak halleder. Replica: Elasticsearch normalde (default) her indeks için 5 ana shard ve 1 replica oluşturur, yani her bir indeks 5 adet shard’a sahip ve her shard bir replica içermektedir. Aşağıda bu durumu gösteren bir ekran görüntüsü verilmiştir.  http://:9200/_cat/shards Bu performans iyileştirme adımları, tek sunucu (node) üzerinde çalışan Elasticsearch üzerinde yapılmıştır, yani dağıtık bir sistem üzerinde iyileştirme yapmak buradaki anlatılacaklardan farklı olacaktır. (Bazı kısımları benzerlik gösterse dahi)\nNot : Bu iyileştirme işlemleri, çalıştırılan sunucu sayısına (dağıtık sistem ise), internet hızına (dağıtık sistem ise), sunucuda çalışan işletim sisteminden, kullandığı disk, CPU ve RAM kapasitesine göre değişiklik gösterebilir.Paralel Bulk indeksleme Elasticsearch üzerinde indeksleme işlemi birkaç farklı yöntem ile yapılabilmektedir bunlardan bazıları, tek tek indeksleme, bulk indeksleme ve parallel indekslemedir.\nTek tek indeksleme yöntemi, tahmin edeceğiniz üzere veri büyük olduğunda tercih edilecek bir yöntem değildir, nedeni ise her kayıt için elasticsearche istekte bulunmasından dolayıdır. Yani 10000 adet satır için 10000 istek gönderilecek demektir, bunun yerine bulk indeksleme tercih edilir 10000 adet kayıt için tek istek gönderimi yapar böylece hem istek sayısı minimuma indirilmiş olur, hem de indeksleme süresi azaltılmış olur. Bunun bir adım daha gelişmişi ise paralel bulk tır, bu indeksleme yönteminde ise birden fazla thread ile veri elasticsearche gönderilecektir sağlar. Bizim çalışmamızda paralel bulk işlemi kullanılmıştır.\nBu çalışmada, Elasticsearch ün Python modülleri kullanılmıştır, bu modülde paralel bulk kullanımı aşağıdaki şekildedir.\nParalel bulk kullanabilmek için Python generator kullanmak tercih edilen yöntemlerden biridir, nedeni hem ram kullanımı az olur, hemde tekrarlı (iterate) bir yapıya sahiptir.\nÖrnek generator yapısı :\ndef gendata(docs_list): for json in docs_list: yield { \"_index\": \"herhangibirsey\", \"_type\": \"_doc\", \"isim\":json['isim'], \"soyisim\":json['soyisim'], \"sehir\": json['sehir'], \"yas\":json['yas'], \"meslek\":json['meslek'] } Bu generator yapısında, gendata fonksiyonu docs_list adında bir liste alıyor ve bu listenin içeriği şu şekilde olduğunu varsayıyoruz:\ndocs_list= [{\"isim\": \"Mehmet\",\"soyisim\": \"Ataklar\",\"sehir\": \"Kocaeli\",\"yas\": 45,\"meslek\": \"Ogretmen\"}] gendata fonksiyonu docs_list listesi icerisindeki her bir dokumandan gereken alanlari alarak indeksleme fonksiyonuna vermektedir. Parallel bulk, Python script üzerinden şu şekilde çağrılabilir.\nfor response in parallel_bulk(elasticDeamon, gendata(doc_records), thread_count=7): pass Indeks yenileme aralığını kaldırma (refresh_interval) Node üzerinde bulunan indeks e, bulk indexleme işlemi yapılırken, indeks yenileme aralığı bulk indeksleme süresi boyunca ortadan kaldırılmalıdır. Çünkü elasticsearch ün her yenileme yapması sunucu üzerinde segment oluşturmasını sağlamaktadır, bu hem makinen kaynaklarına dezavantaj olarak yansımaktadır, ram ve cpu kullanımını artıran pahalı bir işlemdir.\nKibana üzerinde bulunan “Dev Tools” kısmından aşağıdaki verilen komut ile kaldırılabilir.\nPUT //_settings { \"index\": { \"refresh_interval\": -1 } } Terminal üzerinden:\ncurl -X PUT \":9200//_settings\" -H 'Content-Type: application/json' -d' { \"index\" : { \"refresh_interval\" : -1 } } ' Bulk indeksleme işlemi sona erdiğinde ise, aynı komutlar kullanılarak, yenileme aralığı “null” a eşitlenebilir. Böylece kullanıcı kibana üzerinden, yenileme aralığını kendisi ayarlayabilir.\nPUT //_settings { \"index\": { \"refresh_interval\": null } } Indeks kopyalarını devre dışı bırakmak (Replica) Kulağa hoş gelmesede indeks kopyalarını (replicas) devre dışı bırakmak indeksleme hızını artırır, en büyük dezavantajı indeksi herhangi bir hata durumunda veri kaybına karşı savunmasız bırakır.\nKibana “DevTools” kısmından kopyaların devre dışı bırakılması.\nPUT //_settings { \"index\" : { \"number_of_replicas\" : 0 } } Terminal üzerinden:\ncurl -X PUT \":9200//_settings\" -H 'Content-Type: application/json' -d' { \"index\" : { \"number_of_replicas\" : 0 } } ' Swap alanını kaldırmak. (Sunucu üzerindeki) Elasticsearchü hızlı yapan faktörlerden en önemlisi ram üzerinden işlem yapmasıdır. Linux sunucularında bulunan swap alanı, ram de yeterli alan kalmadığında veya ram üzerinde uzun süre işlem yapılmayan (aktif olmayan) dosyaların disk üzerinde kısa süreliğine saklanmasından oluşan alandır. Bu elasticsearh için dezavantaj olabilmektedir, elasticsearchün tamamen ram üzerinden işlem yapmasını sağlamak adına swap alanını kaldırmak indeksleme ve arama yapma hızını artıracaktır.\nSwap alanını geçici olarak şu şekilde kaldırabilirsiniz, terminal üzerinden bu komutu yazmanız yeterlidir.\n$ swapoff -a Swap alanını tamamen kaldırabilmek için “root” yetkisi ile /etc/fstab dosyası içerisinde swap kelimesi geçen kısmı yorum satırı yapmanız yeterli olacaktır.\nSwap alanını ortadan kaldırdıktan sonra sunucu üzerinde çalışan elasticsearch ayarlarında ufak bir değişiklik yapmak gerekecektir.\n/etc/elasticsearch/elasticsearch.yml\nelasticsearch.yml dosyası içerisine şu parametreyi eklemeniz gerekmektedir.\nbootstrap.mlockall: true Bu işlem elasticsearch ün tamamen RAM üzerinden işlem yapmasını sağlayacaktır.\nJVM Heap Alanını Artırmak Elasticsearch JVM heap, verileri hızlı bir şekilde işlemek ve veriler üzerindeki işlemleri yapabilmek için elasticsearche özel olarak ayrılmış bir alan. Bu alan normalde (default olarak) 1 GB alana sahiptir, eğer sunucu üzerinde yeterli miktarda RAM mevcut ise bu alanı artırmak indeksleme ve işlem yapma hızını artıracaktır.\nBurada önemli olan JVM Heap alanı 64 Bit yapıya sahip bir sunucu için maksimum 32 GB a kadar artırılmalıdır, sunucu üzerinde çok daha fazla RAM olsa dahi 32 GB limiti geçmemek gerekmektedir. Bununla ilgili detaylı açıklamaya buradan erişebilirsiniz: https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html\nJVM Heap alanı ayarlanırken genellikle fiziksel ram boyutunun yarısı kadar heap alanı vermek tercih edilir, 32 GB boyutunu geçmeyecek şekilde.\nJVM Heap ayarları şu şekilde yapılabilir, Debian tabanlı bir işletim sisteminde elasticsearch ün bulunduğu dizin altında jvm.options adında bir dosya bulunmaktadır.\nEğer heap alanını 16 GB ayarlamak isterseniz(fiziksel RAM in en az 32 GB olduğundan emin olunuz ), jvm.options dosyası içerisine şu şekilde kaydedebilirsiniz.\n/etc/elasticsearch/jvm.options ## bu jvm.options dosyası içerisine aşağıda verilen parametler girilir. -Xms16GB -Xmx16GB Bu parametreler, jvm.options dosyası içerisine kaydedildikten sonraki adımda ise elasticsearch servisini yeniden başlatmayı unutmayınız.\nsudo service elasticsearch restart SSD veya RAID 0 disk kullanımı HDD disklere göre çok hızlı olan SSD diskler, elasticsearch ün veriyi daha hızlı işlemesine, verimliliği artırmasına direkt olarak etki edecektir. RAID diskleri kullanırken RAID 0 haricindeki tiplerini kullanmak tercih edilmez.\nBu kısımda elasticsearch performansını artırmak için yapılması gerekli olabilecek bazı adımlardan bahsedildi bunlar özet olarak.\n Paralel bulk indekslemek JVM heap alanı artırmak İndeks kopyaları devre dışı bırakmak İndeks yenileme aralığını devre dışı bırakmak Sunucu Swap alanını kaldırmak SSD veya RAID 0 Disk Kullanmak  Bu, elasticsearch performans iyileştirme adımlarını gösteren birinci kısım, ikinci kısımda, elasticsearch üzerinde indeks oluştururken, mapping sisteminin verimize göre nasıl yapılandırılması gerektiğinden, indeks üzerinde otomatik olarak oluşturulan bazı alanların kaldırılmasından, optimum shard sayısının belirlenmesinden, indeks performans (benchmarking) ölçümlerinden ve Grafana üzerinden elasticsearch değerlerinin (CPU,I/O, RAM, DISK kullanımının) izlenmesi anlatılacaktır.\nBu çalışma esnasında yararlanılan kaynaklar https://blog.codecentric.de/en/2014/05/elasticsearch-indexing-performance-cheatsheethttps://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.htmlhttps://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.htmhttps://elasticsearch-py.readthedocs.io/en/master","wordCount":"1076","inLanguage":"en","datePublished":"2019-02-17T09:04:03Z","dateModified":"2019-02-17T09:04:03Z","author":{"@type":"Person","name":"mrturkmen"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mrtrkmn.github.io/posts/elasticsearch-performans-art%C4%B1r%C4%B1m%C4%B1/"},"publisher":{"@type":"Organization","name":"mrturkmen","logo":{"@type":"ImageObject","url":"https://mrtrkmn.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://mrtrkmn.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://mrtrkmn.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://mrtrkmn.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mrtrkmn.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://mrtrkmn.github.io/posts/>Posts</a></div><h1 class=post-title>elasticsearch/performans</h1><div class=post-description>Elasticsearch ortamı performans artırımı</div><div class=post-meta>February 17, 2019&nbsp;·&nbsp;6 min&nbsp;·&nbsp;mrturkmen&nbsp;|&nbsp;<a href=https://github.com/mrtrkmn/mrtrkmn.github.io/tree/master/content/posts/elasticsearch-performans-art%c4%b1r%c4%b1m%c4%b1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#giri%c5%9f aria-label=Giriş>Giriş</a></li><li><a href=#paralel-bulk-indeksleme aria-label="Paralel Bulk indeksleme">Paralel Bulk indeksleme</a></li><li><a href=#indeks-yenileme-aral%c4%b1%c4%9f%c4%b1n%c4%b1-kald%c4%b1rma-refresh_interval aria-label="Indeks yenileme aralığını kaldırma (refresh_interval)">Indeks yenileme aralığını kaldırma (refresh_interval)</a></li><li><a href=#indeks-kopyalar%c4%b1n%c4%b1-devre-d%c4%b1%c5%9f%c4%b1-b%c4%b1rakmak-replica aria-label="Indeks kopyalarını devre dışı bırakmak (Replica)">Indeks kopyalarını devre dışı bırakmak (Replica)</a></li><li><a href=#swap-alan%c4%b1n%c4%b1-kald%c4%b1rmak-sunucu-%c3%bczerindeki aria-label="Swap alanını kaldırmak. (Sunucu üzerindeki)">Swap alanını kaldırmak. (Sunucu üzerindeki)</a></li><li><a href=#jvm-heap-alan%c4%b1n%c4%b1-art%c4%b1rmak aria-label="JVM Heap Alanını Artırmak">JVM Heap Alanını Artırmak</a></li><li><a href=#ssd-veya-raid-0-disk-kullan%c4%b1m%c4%b1 aria-label="SSD veya RAID 0 disk kullanımı">SSD veya RAID 0 disk kullanımı</a></li><li><a href=#bu-%c3%a7al%c4%b1%c5%9fma-esnas%c4%b1nda-yararlan%c4%b1lan-kaynaklar aria-label="Bu çalışma esnasında yararlanılan kaynaklar">Bu çalışma esnasında yararlanılan kaynaklar</a></li></ul></div></details></div><div class=post-content><h4 id=giriş>Giriş<a hidden class=anchor aria-hidden=true href=#giriş>#</a></h4><p>Elasticsearch üzerinde büyük boyuttaki verileri hızlı bir şekilde işlemek çaba gerektiren işlerden biridir. Bu yazıda bir çalışma esnasında yapılan elasticsearch performans iyileştirmelerini ve nasıl yapıldığını anlatmaya çalışacağım.</p><p>Bu iyileştirme işlemlerinin nasıl yapıldığına geçmeden once elasticsearch mimarisinde bulunan bazı bileşenlerden bahsetmekte yarar var.</p><ul><li><strong>Cluster</strong> : Elasticsearch bir veya birden fazla bilgisayarda entegre şekilde çalışabilir ve bu elasticsearch ün çalıştığı makinelere NODE denir. Cluster (Küme) ise bu node’ların oluşturduğu gruba verilen yapıya denir.</li><li><strong>Index</strong> : Elasticsearch üzerinde veriler indexlerde tutulur, index basit olarak dökümanların toplandığı ve tutulduğu yapıdır.</li><li><strong>Shard</strong>: Elasticsearch ü birden fazla makine üzerinde (sanal veya fiziksel makine) tutabildiğimizden dolayı, indekslerde tutulan veriler bu cluster adı verdiğimiz ortamlarda dağıtık (distributed) şekilde tutulur. Bu işlemin yönetim kısmını elasticsearch otomatik olarak halleder.</li><li><strong>Replica</strong>: Elasticsearch normalde (default) her indeks için 5 ana shard ve 1 replica oluşturur, yani her bir indeks 5 adet shard’a sahip ve her shard bir replica içermektedir. Aşağıda bu durumu gösteren bir ekran görüntüsü verilmiştir.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>http://&lt;elk-ip&gt;:9200/_cat/shards
</code></pre></div><p><img loading=lazy src=../../images/figure_1.png alt></p><p>Bu performans iyileştirme adımları, tek sunucu (node) üzerinde çalışan Elasticsearch üzerinde yapılmıştır, yani dağıtık bir sistem üzerinde iyileştirme yapmak buradaki anlatılacaklardan farklı olacaktır. (Bazı kısımları benzerlik gösterse dahi)</p><p><strong>Not : Bu iyileştirme işlemleri, çalıştırılan sunucu sayısına (dağıtık sistem ise), internet hızına (dağıtık sistem ise), sunucuda çalışan işletim sisteminden, kullandığı disk, CPU ve RAM kapasitesine göre değişiklik gösterebilir.</strong></p><h4 id=paralel-bulk-indeksleme>Paralel Bulk indeksleme<a hidden class=anchor aria-hidden=true href=#paralel-bulk-indeksleme>#</a></h4><p>Elasticsearch üzerinde indeksleme işlemi birkaç farklı yöntem ile yapılabilmektedir bunlardan bazıları, tek tek indeksleme, bulk indeksleme ve parallel indekslemedir.</p><p>Tek tek indeksleme yöntemi, tahmin edeceğiniz üzere veri büyük olduğunda tercih edilecek bir yöntem değildir, nedeni ise her kayıt için elasticsearche istekte bulunmasından dolayıdır. Yani 10000 adet satır için 10000 istek gönderilecek demektir, bunun yerine bulk indeksleme tercih edilir 10000 adet kayıt için tek istek gönderimi yapar böylece hem istek sayısı minimuma indirilmiş olur, hem de indeksleme süresi azaltılmış olur. Bunun bir adım daha gelişmişi ise paralel bulk tır, bu indeksleme yönteminde ise birden fazla thread ile veri elasticsearche gönderilecektir sağlar. Bizim çalışmamızda paralel bulk işlemi kullanılmıştır.</p><p>Bu çalışmada, Elasticsearch ün Python modülleri kullanılmıştır, bu modülde paralel bulk kullanımı aşağıdaki şekildedir.</p><p>Paralel bulk kullanabilmek için Python generator kullanmak tercih edilen yöntemlerden biridir, nedeni hem ram kullanımı az olur, hemde tekrarlı (iterate) bir yapıya sahiptir.</p><p>Örnek generator yapısı :</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gendata</span>(docs_list):

     <span style=color:#66d9ef>for</span> json <span style=color:#f92672>in</span> docs_list:

        <span style=color:#66d9ef>yield</span> {
            <span style=color:#e6db74>&#34;_index&#34;</span>: <span style=color:#e6db74>&#34;herhangibirsey&#34;</span>,
            <span style=color:#e6db74>&#34;_type&#34;</span>: <span style=color:#e6db74>&#34;_doc&#34;</span>,
            <span style=color:#e6db74>&#34;isim&#34;</span>:json[<span style=color:#e6db74>&#39;isim&#39;</span>],
            <span style=color:#e6db74>&#34;soyisim&#34;</span>:json[<span style=color:#e6db74>&#39;soyisim&#39;</span>],
            <span style=color:#e6db74>&#34;sehir&#34;</span>: json[<span style=color:#e6db74>&#39;sehir&#39;</span>],
            <span style=color:#e6db74>&#34;yas&#34;</span>:json[<span style=color:#e6db74>&#39;yas&#39;</span>],
            <span style=color:#e6db74>&#34;meslek&#34;</span>:json[<span style=color:#e6db74>&#39;meslek&#39;</span>]
        }

</code></pre></div><p>Bu generator yapısında, gendata fonksiyonu docs_list adında bir liste alıyor ve bu listenin içeriği şu şekilde olduğunu varsayıyoruz:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>
docs_list<span style=color:#f92672>=</span> [{<span style=color:#e6db74>&#34;isim&#34;</span>: <span style=color:#e6db74>&#34;Mehmet&#34;</span>,<span style=color:#e6db74>&#34;soyisim&#34;</span>: <span style=color:#e6db74>&#34;Ataklar&#34;</span>,<span style=color:#e6db74>&#34;sehir&#34;</span>: <span style=color:#e6db74>&#34;Kocaeli&#34;</span>,<span style=color:#e6db74>&#34;yas&#34;</span>: <span style=color:#ae81ff>45</span>,<span style=color:#e6db74>&#34;meslek&#34;</span>: <span style=color:#e6db74>&#34;Ogretmen&#34;</span>}]

</code></pre></div><p><code>gendata</code> fonksiyonu <code>docs_list</code> listesi icerisindeki her bir dokumandan gereken alanlari alarak indeksleme fonksiyonuna vermektedir. Parallel bulk, Python script üzerinden şu şekilde çağrılabilir.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python> <span style=color:#66d9ef>for</span> response <span style=color:#f92672>in</span> parallel_bulk(elasticDeamon, gendata(doc_records), thread_count<span style=color:#f92672>=</span><span style=color:#ae81ff>7</span>):
    <span style=color:#66d9ef>pass</span> 
</code></pre></div><h4 id=indeks-yenileme-aralığını-kaldırma-refresh_interval>Indeks yenileme aralığını kaldırma (refresh_interval)<a hidden class=anchor aria-hidden=true href=#indeks-yenileme-aralığını-kaldırma-refresh_interval>#</a></h4><p>Node üzerinde bulunan indeks e, bulk indexleme işlemi yapılırken, indeks yenileme aralığı bulk indeksleme süresi boyunca ortadan kaldırılmalıdır. Çünkü elasticsearch ün her yenileme yapması sunucu üzerinde segment oluşturmasını sağlamaktadır, bu hem makinen kaynaklarına dezavantaj olarak yansımaktadır, ram ve cpu kullanımını artıran pahalı bir işlemdir.</p><p>Kibana üzerinde bulunan “Dev Tools” kısmından aşağıdaki verilen komut ile kaldırılabilir.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>    PUT /&lt;indeks-ismi&gt;/_settings

    <span style=color:#f92672>{</span>
        <span style=color:#e6db74>&#34;index&#34;</span>: <span style=color:#f92672>{</span>

            <span style=color:#e6db74>&#34;refresh_interval&#34;</span>: -1

        <span style=color:#f92672>}</span>

    <span style=color:#f92672>}</span>
</code></pre></div><p>Terminal üzerinden:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -X PUT <span style=color:#e6db74>&#34;&lt;elk-ip&gt;:9200/&lt;index-ismi&gt;/_settings&#34;</span> -H <span style=color:#e6db74>&#39;Content-Type: application/json&#39;</span> -d<span style=color:#e6db74>&#39; { &#34;index&#34; : { &#34;refresh_interval&#34; : -1 } } &#39;</span>

</code></pre></div><p>Bulk indeksleme işlemi sona erdiğinde ise, aynı komutlar kullanılarak, yenileme aralığı “null” a eşitlenebilir. Böylece kullanıcı kibana üzerinden, yenileme aralığını kendisi ayarlayabilir.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>PUT /&lt;index-ismi&gt;/_settings

<span style=color:#f92672>{</span>

    <span style=color:#e6db74>&#34;index&#34;</span>: <span style=color:#f92672>{</span>

        <span style=color:#e6db74>&#34;refresh_interval&#34;</span>: null



    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>
</code></pre></div><h4 id=indeks-kopyalarını-devre-dışı-bırakmak-replica>Indeks kopyalarını devre dışı bırakmak (Replica)<a hidden class=anchor aria-hidden=true href=#indeks-kopyalarını-devre-dışı-bırakmak-replica>#</a></h4><p>Kulağa hoş gelmesede indeks kopyalarını (replicas) devre dışı bırakmak indeksleme hızını artırır, en büyük dezavantajı indeksi herhangi bir hata durumunda veri kaybına karşı savunmasız bırakır.</p><p>Kibana “DevTools” kısmından kopyaların devre dışı bırakılması.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>PUT /&lt;indeks-ismi&gt;/_settings

<span style=color:#f92672>{</span>

    <span style=color:#e6db74>&#34;index&#34;</span> : <span style=color:#f92672>{</span>

        <span style=color:#e6db74>&#34;number_of_replicas&#34;</span> : <span style=color:#ae81ff>0</span>

    <span style=color:#f92672>}</span>

<span style=color:#f92672>}</span>

</code></pre></div><p>Terminal üzerinden:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>curl -X PUT <span style=color:#e6db74>&#34;&lt;elk-ip&gt;:9200/&lt;index-ismi&gt;/_settings&#34;</span> -H <span style=color:#e6db74>&#39;Content-Type: application/json&#39;</span> -d<span style=color:#e6db74>&#39; { &#34;index&#34; : { &#34;number_of_replicas&#34; : 0 } } &#39;</span>
</code></pre></div><h4 id=swap-alanını-kaldırmak-sunucu-üzerindeki>Swap alanını kaldırmak. (Sunucu üzerindeki)<a hidden class=anchor aria-hidden=true href=#swap-alanını-kaldırmak-sunucu-üzerindeki>#</a></h4><p>Elasticsearchü hızlı yapan faktörlerden en önemlisi ram üzerinden işlem yapmasıdır. Linux sunucularında bulunan swap alanı, ram de yeterli alan kalmadığında veya ram üzerinde uzun süre işlem yapılmayan (aktif olmayan) dosyaların disk üzerinde kısa süreliğine saklanmasından oluşan alandır. Bu elasticsearh için dezavantaj olabilmektedir, elasticsearchün tamamen ram üzerinden işlem yapmasını sağlamak adına swap alanını kaldırmak indeksleme ve arama yapma hızını artıracaktır.</p><p>Swap alanını geçici olarak şu şekilde kaldırabilirsiniz, terminal üzerinden bu komutu yazmanız yeterlidir.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ swapoff -a
</code></pre></div><p>Swap alanını tamamen kaldırabilmek için “root” yetkisi ile <code>/etc/fstab</code> dosyası içerisinde <code>swap</code> kelimesi geçen kısmı yorum satırı yapmanız yeterli olacaktır.</p><p>Swap alanını ortadan kaldırdıktan sonra sunucu üzerinde çalışan elasticsearch ayarlarında ufak bir değişiklik yapmak gerekecektir.</p><p><code>/etc/elasticsearch/elasticsearch.yml</code></p><p><code>elasticsearch.yml</code> dosyası içerisine şu parametreyi eklemeniz gerekmektedir.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>bootstrap.mlockall</span>: <span style=color:#66d9ef>true</span> 
</code></pre></div><p>Bu işlem elasticsearch ün tamamen RAM üzerinden işlem yapmasını sağlayacaktır.</p><h4 id=jvm-heap-alanını-artırmak>JVM Heap Alanını Artırmak<a hidden class=anchor aria-hidden=true href=#jvm-heap-alanını-artırmak>#</a></h4><p>Elasticsearch JVM heap, verileri hızlı bir şekilde işlemek ve veriler üzerindeki işlemleri yapabilmek için elasticsearche özel olarak ayrılmış bir alan. Bu alan normalde (default olarak) 1 GB alana sahiptir, eğer sunucu üzerinde yeterli miktarda RAM mevcut ise bu alanı artırmak indeksleme ve işlem yapma hızını artıracaktır.</p><p>Burada önemli olan JVM Heap alanı 64 Bit yapıya sahip bir sunucu için <strong><em>maksimum</em></strong> 32 GB a kadar artırılmalıdır, sunucu üzerinde çok daha fazla RAM olsa dahi 32 GB limiti geçmemek gerekmektedir. Bununla ilgili detaylı açıklamaya buradan erişebilirsiniz: <a href=https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html>https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.html</a></p><p>JVM Heap alanı ayarlanırken genellikle fiziksel ram boyutunun yarısı kadar heap alanı vermek tercih edilir, 32 GB boyutunu geçmeyecek şekilde.</p><p>JVM Heap ayarları şu şekilde yapılabilir, Debian tabanlı bir işletim sisteminde elasticsearch ün bulunduğu dizin altında <strong>jvm.options</strong> adında bir dosya bulunmaktadır.</p><p>Eğer heap alanını 16 GB ayarlamak isterseniz(fiziksel RAM in en az 32 GB olduğundan emin olunuz ), jvm.options dosyası içerisine şu şekilde kaydedebilirsiniz.</p><pre><code class=language-raw data-lang=raw>
/etc/elasticsearch/jvm.options

    ## bu jvm.options dosyası içerisine aşağıda verilen parametler girilir.

-Xms16GB
-Xmx16GB  

</code></pre><p>Bu parametreler, <code>jvm.options</code> dosyası içerisine kaydedildikten sonraki adımda ise elasticsearch servisini yeniden başlatmayı unutmayınız.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>sudo service elasticsearch restart
</code></pre></div><h4 id=ssd-veya-raid-0-disk-kullanımı>SSD veya RAID 0 disk kullanımı<a hidden class=anchor aria-hidden=true href=#ssd-veya-raid-0-disk-kullanımı>#</a></h4><p>HDD disklere göre çok hızlı olan SSD diskler, elasticsearch ün veriyi daha hızlı işlemesine, verimliliği artırmasına direkt olarak etki edecektir. RAID diskleri kullanırken RAID 0 haricindeki tiplerini kullanmak tercih edilmez.</p><p>Bu kısımda elasticsearch performansını artırmak için yapılması gerekli olabilecek bazı adımlardan bahsedildi bunlar özet olarak.</p><ul><li><em>Paralel bulk indekslemek</em></li><li><em>JVM heap alanı artırmak</em></li><li><em>İndeks kopyaları devre dışı bırakmak</em></li><li><em>İndeks yenileme aralığını devre dışı bırakmak</em></li><li><em>Sunucu Swap alanını kaldırmak</em></li><li><em>SSD veya RAID 0 Disk Kullanmak</em></li></ul><p>Bu, elasticsearch performans iyileştirme adımlarını gösteren birinci kısım, ikinci kısımda, elasticsearch üzerinde indeks oluştururken, mapping sisteminin verimize göre nasıl yapılandırılması gerektiğinden, indeks üzerinde otomatik olarak oluşturulan bazı alanların kaldırılmasından, optimum shard sayısının belirlenmesinden, indeks performans (benchmarking) ölçümlerinden ve Grafana üzerinden elasticsearch değerlerinin (CPU,I/O, RAM, DISK kullanımının) izlenmesi anlatılacaktır.</p><h4 id=bu-çalışma-esnasında-yararlanılan-kaynaklar>Bu çalışma esnasında yararlanılan kaynaklar<a hidden class=anchor aria-hidden=true href=#bu-çalışma-esnasında-yararlanılan-kaynaklar>#</a></h4><p><a href=https://blog.codecentric.de/en/2014/05/elasticsearch-indexing-performance-cheatsheet%3E>https://blog.codecentric.de/en/2014/05/elasticsearch-indexing-performance-cheatsheet></a></p><p><a href=https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html>https://www.elastic.co/guide/en/elasticsearch/reference/master/tune-for-indexing-speed.html</a></p><p><a href=https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.htm>https://www.elastic.co/guide/en/elasticsearch/guide/current/heap-sizing.htm</a></p><p><a href=https://elasticsearch-py.readthedocs.io/en/master>https://elasticsearch-py.readthedocs.io/en/master</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://mrtrkmn.github.io/tags/elasticsearch/>elasticsearch</a></li><li><a href=https://mrtrkmn.github.io/tags/cluster/>cluster</a></li><li><a href=https://mrtrkmn.github.io/tags/performans/>performans</a></li><li><a href=https://mrtrkmn.github.io/tags/performance/>performance</a></li></ul><nav class=paginav><a class=prev href=https://mrtrkmn.github.io/posts/no-space-left-on-device/><span class=title>« Prev Page</span><br><span>no space left on this device</span></a>
<a class=next href=https://mrtrkmn.github.io/posts/vim/><span class=title>Next Page »</span><br><span>vim</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share elasticsearch/performans  on twitter" href="https://twitter.com/intent/tweet/?text=elasticsearch%2fperformans%20&url=https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f&hashtags=elasticsearch%2ccluster%2cperformans%2cperformance"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share elasticsearch/performans  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f&title=elasticsearch%2fperformans%20&summary=elasticsearch%2fperformans%20&source=https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share elasticsearch/performans  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f&title=elasticsearch%2fperformans%20"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share elasticsearch/performans  on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share elasticsearch/performans  on whatsapp" href="https://api.whatsapp.com/send?text=elasticsearch%2fperformans%20%20-%20https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share elasticsearch/performans  on telegram" href="https://telegram.me/share/url?text=elasticsearch%2fperformans%20&url=https%3a%2f%2fmrtrkmn.github.io%2fposts%2felasticsearch-performans-art%25C4%25B1r%25C4%25B1m%25C4%25B1%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://mrtrkmn.github.io/>mrturkmen</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script><script>document.querySelectorAll('pre > code').forEach(b=>{const c=b.parentNode.parentNode,a=document.createElement('button');a.classList.add('copy-code'),a.innerText='copy';function d(){a.innerText='copied!',setTimeout(()=>{a.innerText='copy'},2e3)}a.addEventListener('click',e=>{if('clipboard'in navigator){navigator.clipboard.writeText(b.textContent),d();return}const a=document.createRange();a.selectNodeContents(b);const c=window.getSelection();c.removeAllRanges(),c.addRange(a);try{document.execCommand('copy'),d()}catch(a){}c.removeRange(a)}),c.classList.contains("highlight")?c.appendChild(a):c.parentNode.firstChild==c||(b.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?b.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(a):b.parentNode.appendChild(a))})</script></body></html>